import type { IExploit, IExploitUID } from '@lib/exploits/interfaces';
import { useEffect, useState } from 'react';
import type { SemVer } from 'semver';

import type { OperationState } from '~lib/state.js';

// Somehow this will only resolve when not using aliases (yes, I spent 2 days on this)
// And yes, ts will shout at you
import { validateExploitSchema } from '../../../lib/exploits/schemas/ExploitSchema.js';

const fetchTimeout = async (
	url: URL,
	ms: number,
	{ signal, ...options }: RequestInit = {}
) => {
	const controller = new AbortController();
	const promise = fetch(url, { signal: controller.signal, ...options });
	if (signal) signal.addEventListener('abort', () => controller.abort());
	const timeout = setTimeout(() => controller.abort(), ms);
	try {
		return await promise;
	} finally {
		clearTimeout(timeout);
	}
};

export const useExploits = (
	tab: chrome.tabs.Tab | undefined,
	endpoints: Array<URL>
) => {
	const [status, setStatus] = useState<OperationState>('LOADING');
	const [exploits, setExploits] = useState<Array<IExploit>>([]);

	const controller = new AbortController();

	useEffect(() => {
		if (tab === undefined || !tab.url) {
			console.log('tab');
			setStatus('LOADING');
			return;
		}
		fetchExploits(tab.url);

		async function fetchExploits(tabUrl: string) {
			let total: Array<IExploit> = [];

			for (const endpoint of endpoints) {
				let resp;

				try {
					resp = await fetchTimeout(endpoint, 4000, {
						signal: controller.signal
					});
				} catch (e) {
					setStatus('ERROR');
					return;
				}

				if (!resp.ok) continue;

				const exploits = await resp.json();
				if (!Array.isArray(exploits)) continue;

				const validExploits = exploits
					.filter(
						(e) =>
							validateExploitSchema(e) &&
							new RegExp(e.url).test(tabUrl)
					)
					.map((e) => {
						return {
							name: e.name,
							description: e.description,
							location: new URL(e.location),
							matches: [new RegExp(e.url)],
							version: e.version as SemVer,
							uid: e.uid as IExploitUID
						} as IExploit;
					});
				total = total.concat(validExploits);
			}
			setStatus('SUCCESS');
			setExploits(total);
		}
	}, [tab, endpoints]);

	return { status, exploits };
};
